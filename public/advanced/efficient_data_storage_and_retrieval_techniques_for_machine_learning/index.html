<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Efficient Data Storage and Retrieval Techniques for Machine Learning | Data Driven Discovery - D3</title>
<meta name="keywords" content="Machine Learning, Data Storage, Data Retrieval, Advanced Topic">
<meta name="description" content="Efficient Data Storage and Retrieval Techniques for Machine Learning In the world of machine learning (ML), the efficiency and scalability of data storage and retrieval can significantly influence the performance and feasibility of ML models. As the volume of data continues to grow exponentially, it becomes crucial for data scientists, data engineers, and ML practitioners to adopt efficient techniques for managing data. This article aims to explore some of the best practices and techniques for storing and retrieving data in the context of machine learning, offering insights that cater to both beginners and advanced users.">
<meta name="author" content="">
<link rel="canonical" href="https://lustrous-paprenjak-b7c3d8.netlify.app/advanced/Efficient_Data_Storage_and_Retrieval_Techniques_for_Machine_Learning/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lustrous-paprenjak-b7c3d8.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lustrous-paprenjak-b7c3d8.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lustrous-paprenjak-b7c3d8.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lustrous-paprenjak-b7c3d8.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://lustrous-paprenjak-b7c3d8.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Efficient Data Storage and Retrieval Techniques for Machine Learning" />
<meta property="og:description" content="Efficient Data Storage and Retrieval Techniques for Machine Learning In the world of machine learning (ML), the efficiency and scalability of data storage and retrieval can significantly influence the performance and feasibility of ML models. As the volume of data continues to grow exponentially, it becomes crucial for data scientists, data engineers, and ML practitioners to adopt efficient techniques for managing data. This article aims to explore some of the best practices and techniques for storing and retrieving data in the context of machine learning, offering insights that cater to both beginners and advanced users." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lustrous-paprenjak-b7c3d8.netlify.app/advanced/Efficient_Data_Storage_and_Retrieval_Techniques_for_Machine_Learning/" /><meta property="article:section" content="advanced" />
<meta property="article:published_time" content="2024-02-05T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-02-05T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Efficient Data Storage and Retrieval Techniques for Machine Learning"/>
<meta name="twitter:description" content="Efficient Data Storage and Retrieval Techniques for Machine Learning In the world of machine learning (ML), the efficiency and scalability of data storage and retrieval can significantly influence the performance and feasibility of ML models. As the volume of data continues to grow exponentially, it becomes crucial for data scientists, data engineers, and ML practitioners to adopt efficient techniques for managing data. This article aims to explore some of the best practices and techniques for storing and retrieving data in the context of machine learning, offering insights that cater to both beginners and advanced users."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Advanceds",
      "item": "https://lustrous-paprenjak-b7c3d8.netlify.app/advanced/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Efficient Data Storage and Retrieval Techniques for Machine Learning",
      "item": "https://lustrous-paprenjak-b7c3d8.netlify.app/advanced/Efficient_Data_Storage_and_Retrieval_Techniques_for_Machine_Learning/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Efficient Data Storage and Retrieval Techniques for Machine Learning",
  "name": "Efficient Data Storage and Retrieval Techniques for Machine Learning",
  "description": "Efficient Data Storage and Retrieval Techniques for Machine Learning In the world of machine learning (ML), the efficiency and scalability of data storage and retrieval can significantly influence the performance and feasibility of ML models. As the volume of data continues to grow exponentially, it becomes crucial for data scientists, data engineers, and ML practitioners to adopt efficient techniques for managing data. This article aims to explore some of the best practices and techniques for storing and retrieving data in the context of machine learning, offering insights that cater to both beginners and advanced users.",
  "keywords": [
    "Machine Learning", "Data Storage", "Data Retrieval", "Advanced Topic"
  ],
  "articleBody": "Efficient Data Storage and Retrieval Techniques for Machine Learning In the world of machine learning (ML), the efficiency and scalability of data storage and retrieval can significantly influence the performance and feasibility of ML models. As the volume of data continues to grow exponentially, it becomes crucial for data scientists, data engineers, and ML practitioners to adopt efficient techniques for managing data. This article aims to explore some of the best practices and techniques for storing and retrieving data in the context of machine learning, offering insights that cater to both beginners and advanced users.\nIntroduction Machine learning algorithms require access to large datasets to train and improve their accuracy. However, the sheer volume of data and its complexity pose challenges in storing, accessing, and processing this information efficiently. Traditional data storage methods may not suffice in the face of such challenges, necessitating more sophisticated techniques tailored to the needs of ML workflows. Here, we delve into practical solutions for data storage and retrieval, highlighting how these methods can accelerate ML projects and ensure scalability.\nEfficient Data Storage Techniques 1. Data Lakes vs. Data Warehouses Understanding the distinction between data lakes and data warehouses is critical for efficient data storage. Data lakes store raw, unprocessed data in its native format, offering high flexibility and scalability. This is particularly useful for ML projects that require access to raw data for exploratory analysis and feature engineering. On the other hand, data warehouses store structured data, optimized for fast retrieval and analysis. Knowing when to use a data lake versus a data warehouse depends on the specific needs of your ML project.\n2. Columnar Storage Formats For ML applications that involve large-scale analytics, columnar storage formats like Parquet and ORC offer significant advantages. These formats store data in columns rather than rows, facilitating more efficient storage, compression, and query performance. This can dramatically reduce the time required for data retrieval, especially for operations that need to access specific columns of data.\nExample using PySpark: from pyspark.sql import SparkSession # Initialize Spark session spark = SparkSession.builder.appName(\"ColumnarStorageExample\").getOrCreate() # Sample data data = [(\"John Doe\", 30), (\"Jane Smith\", 25)] # Create DataFrame df = spark.createDataFrame(data, [\"Name\", \"Age\"]) # Save DataFrame in Parquet format df.write.parquet(\"/tmp/data.parquet\") # Read DataFrame from Parquet parquet_df = spark.read.parquet(\"/tmp/data.parquet\") parquet_df.show() Expected output:\n+---------+---+ | Name|Age| +---------+---+ | John Doe| 30| |Jane Smith| 25| +---------+---+ 3. Data Indexing and Partitioning Indexing and partitioning data can vastly improve retrieval times by reducing the amount of data scanned during a query. Partitioning divides the dataset into smaller, manageable parts based on certain criteria, such as date or region, allowing queries to focus only on relevant partitions.\nEfficient Data Retrieval Techniques 1. Caching Frequently Accessed Data Caching is a cornerstone technique for efficient data retrieval, particularly for data that is accessed frequently and doesn’t change often. Loading data into memory or using distributed caching systems can dramatically speed up read operations, benefiting ML model training and evaluation processes.\n2. Data Pre-fetching and Pipelining Data pre-fetching involves loading data into cache before it’s needed, anticipating future requests, and thereby reducing wait times. Similarly, data pipelining allows for processing steps to occur in parallel. For instance, while one batch of data is being trained on, the next batch can be pre-processed and loaded, optimizing the overall data flow.\n3. Advanced Query Optimization Techniques Leveraging advanced database optimizations, such as materialized views or query performance tuning, can enhance data retrieval speed. Understanding the underlying mechanisms of your storage solution and fine-tuning it to your specific workload can yield significant performance gains.\nConclusion Efficient data storage and retrieval are foundational to the success of machine learning projects, particularly as data volume and complexity continue to grow. By carefully selecting the appropriate storage formats and techniques, and by optimizing data retrieval processes, ML practitioners can ensure that their projects are scalable, performant, and capable of handling the demands of modern data-driven applications. Implementing these strategies will not only accelerate development cycles but also enhance the overall effectiveness of machine learning solutions.\nRemember, the choice of strategies and technologies must be aligned with the specific requirements and constraints of your project. As such, a thorough assessment of both the data characteristics and the intended ML workflows is crucial before committing to a particular approach. Embrace the practice of continuously evaluating and adapting your data management strategies to keep pace with advancements in the field and shifts in project goals.\n",
  "wordCount" : "736",
  "inLanguage": "en",
  "datePublished": "2024-02-05T00:00:00Z",
  "dateModified": "2024-02-05T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lustrous-paprenjak-b7c3d8.netlify.app/advanced/Efficient_Data_Storage_and_Retrieval_Techniques_for_Machine_Learning/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Data Driven Discovery - D3",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lustrous-paprenjak-b7c3d8.netlify.app/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lustrous-paprenjak-b7c3d8.netlify.app/" accesskey="h" title="Data Driven Discovery - D3 (Alt + H)">Data Driven Discovery - D3</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Efficient Data Storage and Retrieval Techniques for Machine Learning
    </h1>
    <div class="post-meta"><span title='2024-02-05 00:00:00 +0000 UTC'>February 5, 2024</span>

</div>
  </header> 
  <div class="post-content"><h1 id="efficient-data-storage-and-retrieval-techniques-for-machine-learning">Efficient Data Storage and Retrieval Techniques for Machine Learning<a hidden class="anchor" aria-hidden="true" href="#efficient-data-storage-and-retrieval-techniques-for-machine-learning">#</a></h1>
<p>In the world of machine learning (ML), the efficiency and scalability of data storage and retrieval can significantly influence the performance and feasibility of ML models. As the volume of data continues to grow exponentially, it becomes crucial for data scientists, data engineers, and ML practitioners to adopt efficient techniques for managing data. This article aims to explore some of the best practices and techniques for storing and retrieving data in the context of machine learning, offering insights that cater to both beginners and advanced users.</p>
<h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>Machine learning algorithms require access to large datasets to train and improve their accuracy. However, the sheer volume of data and its complexity pose challenges in storing, accessing, and processing this information efficiently. Traditional data storage methods may not suffice in the face of such challenges, necessitating more sophisticated techniques tailored to the needs of ML workflows. Here, we delve into practical solutions for data storage and retrieval, highlighting how these methods can accelerate ML projects and ensure scalability.</p>
<h2 id="efficient-data-storage-techniques">Efficient Data Storage Techniques<a hidden class="anchor" aria-hidden="true" href="#efficient-data-storage-techniques">#</a></h2>
<h3 id="1-data-lakes-vs-data-warehouses">1. Data Lakes vs. Data Warehouses<a hidden class="anchor" aria-hidden="true" href="#1-data-lakes-vs-data-warehouses">#</a></h3>
<p>Understanding the distinction between data lakes and data warehouses is critical for efficient data storage. Data lakes store raw, unprocessed data in its native format, offering high flexibility and scalability. This is particularly useful for ML projects that require access to raw data for exploratory analysis and feature engineering. On the other hand, data warehouses store structured data, optimized for fast retrieval and analysis. Knowing when to use a data lake versus a data warehouse depends on the specific needs of your ML project.</p>
<h3 id="2-columnar-storage-formats">2. Columnar Storage Formats<a hidden class="anchor" aria-hidden="true" href="#2-columnar-storage-formats">#</a></h3>
<p>For ML applications that involve large-scale analytics, columnar storage formats like Parquet and ORC offer significant advantages. These formats store data in columns rather than rows, facilitating more efficient storage, compression, and query performance. This can dramatically reduce the time required for data retrieval, especially for operations that need to access specific columns of data.</p>
<h4 id="example-using-pyspark">Example using PySpark:<a hidden class="anchor" aria-hidden="true" href="#example-using-pyspark">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> pyspark.sql <span style="color:#f92672">import</span> SparkSession
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Initialize Spark session</span>
</span></span><span style="display:flex;"><span>spark <span style="color:#f92672">=</span> SparkSession<span style="color:#f92672">.</span>builder<span style="color:#f92672">.</span>appName(<span style="color:#e6db74">&#34;ColumnarStorageExample&#34;</span>)<span style="color:#f92672">.</span>getOrCreate()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Sample data</span>
</span></span><span style="display:flex;"><span>data <span style="color:#f92672">=</span> [(<span style="color:#e6db74">&#34;John Doe&#34;</span>, <span style="color:#ae81ff">30</span>), (<span style="color:#e6db74">&#34;Jane Smith&#34;</span>, <span style="color:#ae81ff">25</span>)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create DataFrame</span>
</span></span><span style="display:flex;"><span>df <span style="color:#f92672">=</span> spark<span style="color:#f92672">.</span>createDataFrame(data, [<span style="color:#e6db74">&#34;Name&#34;</span>, <span style="color:#e6db74">&#34;Age&#34;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Save DataFrame in Parquet format</span>
</span></span><span style="display:flex;"><span>df<span style="color:#f92672">.</span>write<span style="color:#f92672">.</span>parquet(<span style="color:#e6db74">&#34;/tmp/data.parquet&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Read DataFrame from Parquet</span>
</span></span><span style="display:flex;"><span>parquet_df <span style="color:#f92672">=</span> spark<span style="color:#f92672">.</span>read<span style="color:#f92672">.</span>parquet(<span style="color:#e6db74">&#34;/tmp/data.parquet&#34;</span>)
</span></span><span style="display:flex;"><span>parquet_df<span style="color:#f92672">.</span>show()
</span></span></code></pre></div><p><strong>Expected output:</strong></p>
<pre tabindex="0"><code>+---------+---+
|     Name|Age|
+---------+---+
| John Doe| 30|
|Jane Smith| 25|
+---------+---+
</code></pre><h3 id="3-data-indexing-and-partitioning">3. Data Indexing and Partitioning<a hidden class="anchor" aria-hidden="true" href="#3-data-indexing-and-partitioning">#</a></h3>
<p>Indexing and partitioning data can vastly improve retrieval times by reducing the amount of data scanned during a query. Partitioning divides the dataset into smaller, manageable parts based on certain criteria, such as date or region, allowing queries to focus only on relevant partitions.</p>
<h2 id="efficient-data-retrieval-techniques">Efficient Data Retrieval Techniques<a hidden class="anchor" aria-hidden="true" href="#efficient-data-retrieval-techniques">#</a></h2>
<h3 id="1-caching-frequently-accessed-data">1. Caching Frequently Accessed Data<a hidden class="anchor" aria-hidden="true" href="#1-caching-frequently-accessed-data">#</a></h3>
<p>Caching is a cornerstone technique for efficient data retrieval, particularly for data that is accessed frequently and doesn&rsquo;t change often. Loading data into memory or using distributed caching systems can dramatically speed up read operations, benefiting ML model training and evaluation processes.</p>
<h3 id="2-data-pre-fetching-and-pipelining">2. Data Pre-fetching and Pipelining<a hidden class="anchor" aria-hidden="true" href="#2-data-pre-fetching-and-pipelining">#</a></h3>
<p>Data pre-fetching involves loading data into cache before it&rsquo;s needed, anticipating future requests, and thereby reducing wait times. Similarly, data pipelining allows for processing steps to occur in parallel. For instance, while one batch of data is being trained on, the next batch can be pre-processed and loaded, optimizing the overall data flow.</p>
<h3 id="3-advanced-query-optimization-techniques">3. Advanced Query Optimization Techniques<a hidden class="anchor" aria-hidden="true" href="#3-advanced-query-optimization-techniques">#</a></h3>
<p>Leveraging advanced database optimizations, such as materialized views or query performance tuning, can enhance data retrieval speed. Understanding the underlying mechanisms of your storage solution and fine-tuning it to your specific workload can yield significant performance gains.</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>Efficient data storage and retrieval are foundational to the success of machine learning projects, particularly as data volume and complexity continue to grow. By carefully selecting the appropriate storage formats and techniques, and by optimizing data retrieval processes, ML practitioners can ensure that their projects are scalable, performant, and capable of handling the demands of modern data-driven applications. Implementing these strategies will not only accelerate development cycles but also enhance the overall effectiveness of machine learning solutions.</p>
<p>Remember, the choice of strategies and technologies must be aligned with the specific requirements and constraints of your project. As such, a thorough assessment of both the data characteristics and the intended ML workflows is crucial before committing to a particular approach. Embrace the practice of continuously evaluating and adapting your data management strategies to keep pace with advancements in the field and shifts in project goals.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lustrous-paprenjak-b7c3d8.netlify.app/tags/Machine-Learning/">Machine Learning</a></li>
      <li><a href="https://lustrous-paprenjak-b7c3d8.netlify.app/tags/Data-Storage/">Data Storage</a></li>
      <li><a href="https://lustrous-paprenjak-b7c3d8.netlify.app/tags/Data-Retrieval/">Data Retrieval</a></li>
      <li><a href="https://lustrous-paprenjak-b7c3d8.netlify.app/tags/Advanced-Topic/">Advanced Topic</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://lustrous-paprenjak-b7c3d8.netlify.app/">Data Driven Discovery - D3</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
